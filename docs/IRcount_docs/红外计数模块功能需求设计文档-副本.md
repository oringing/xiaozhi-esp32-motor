### 一、ESP-IDF 项目模板选择建议
![ESP-IDF 项目模板选择](./images/ESP-IDF项目模板选择.png)
推荐选择 **`template-app`** 模板，原因如下：  
1. 现有仓库（`xiaozhi-esp32-motor`）是基于纯 ESP-IDF 框架开发的（使用 `esp_log.h`、`freertos` 等原生组件，无 Arduino 依赖），`template-app` 作为最基础的通用模板，其项目结构（`main` 目录、`CMakeLists.txt` 组织方式）与现有仓库完全兼容，后续代码迁移和封装更顺畅。  
2. 无需引入 Arduino 库（`arduino-as-component` 可能增加冗余依赖），也无需示例模板（`fibonacci-app`）或测试框架（`unity-app`），专注于核心功能开发即可。  


### 二、红外计数模块功能需求设计文档


#### 1. 功能目标  
通过红外发射/接收模块检测车轮编码盘的遮挡信号，实现：  
- 计数编码盘转动的脉冲数（每圈 20 个脉冲，对应编码盘 20 个镂空槽）；  
- 根据脉冲数和车轮直径计算小车前进距离；  
- 集成到现有电机控制逻辑中，支持“前进指定距离”的指令。  


#### 2. 硬件方案  
| 模块         | 连接引脚（ESP32-S3） | 功能描述                     |  
|--------------|----------------------|------------------------------|  
| 红外发射模块 | GPIO_NUM_X（自定义） | 输出高频脉冲信号（红外发射） |  
| 红外接收模块 | GPIO_NUM_Y（自定义） | 接收红外信号，输出高低电平   |  
| 编码盘       | 机械固定在车轮轴上   | 随车轮转动，遮挡/透过红外信号 |  


#### 3. 开发步骤与具体实现  


##### 步骤 1：基础硬件测试（打通发射/接收链路）  
**目标**：验证红外发射模块能按预设频率输出信号，接收模块能正确检测并反馈。  

- **发射模块测试代码**：  
  配置发射引脚为输出模式，先以低频率（如 1Hz）周期性翻转电平（每秒高低电平切换一次），验证接收模块能否同步检测到信号变化。  
  ```c
  #include "driver/gpio.h"
  #include "freertos/FreeRTOS.h"
  #include "freertos/task.h"

  #define IR_TX_PIN GPIO_NUM_18  // 自定义发射引脚

  void app_main() {
    // 配置发射引脚为输出
    gpio_config_t tx_config = {
      .pin_bit_mask = (1ULL << IR_TX_PIN),
      .mode = GPIO_MODE_OUTPUT,
      .pull_up_en = GPIO_PULLUP_DISABLE,
      .pull_down_en = GPIO_PULLDOWN_DISABLE,
      .intr_type = GPIO_INTR_DISABLE
    };
    gpio_config(&tx_config);

    // 1Hz 频率翻转电平（测试用）
    while (1) {
      gpio_set_level(IR_TX_PIN, 1);  // 发射红外
      vTaskDelay(pdMS_TO_TICKS(500));
      gpio_set_level(IR_TX_PIN, 0);  // 停止发射
      vTaskDelay(pdMS_TO_TICKS(500));
    }
  }
  ```  

- **接收模块测试代码**：  
  配置接收引脚为输入模式，通过轮询或中断检测电平变化，打印日志验证是否与发射模块同步。  
  ```c
  #include "driver/gpio.h"
  #include "freertos/FreeRTOS.h"
  #include "freertos/task.h"
  #include "esp_log.h"

  #define IR_RX_PIN GPIO_NUM_19  // 自定义接收引脚
  static const char* TAG = "IR_TEST";

  void app_main() {
    // 配置接收引脚为输入
    gpio_config_t rx_config = {
      .pin_bit_mask = (1ULL << IR_RX_PIN),
      .mode = GPIO_MODE_INPUT,
      .pull_up_en = GPIO_PULLUP_ENABLE,  // 视模块而定，可能需要上拉
      .pull_down_en = GPIO_PULLDOWN_DISABLE,
      .intr_type = GPIO_INTR_DISABLE
    };
    gpio_config(&rx_config);

    // 轮询检测接收信号
    int last_level = -1;
    while (1) {
      int current_level = gpio_get_level(IR_RX_PIN);
      if (current_level != last_level) {
        ESP_LOGI(TAG, "Received level: %d", current_level);
        last_level = current_level;
      }
      vTaskDelay(pdMS_TO_TICKS(10));  // 10ms 轮询一次
    }
  }
  ```  

- **验证标准**：发射模块每秒翻转时，接收模块日志应同步打印电平变化（如 1→0→1→0...）。  


##### 步骤 2：高频发射与脉冲计数（适配编码盘）  
**目标**：提高发射频率，确保编码盘高速转动时脉冲不丢失，实现准确计数。  

- **发射模块高频配置**：  
  红外发射模块需持续输出高频信号（而非 1Hz 翻转），推荐频率 **10kHz~50kHz**（理由：编码盘每圈 20 个槽，若小车最大速度对应车轮每秒转 10 圈，每秒脉冲数为 20×10=200Hz，发射频率需为脉冲频率的 5~10 倍以上才能保证每个槽被检测到，10kHz 足够覆盖高速场景）。  
  使用 `ledc` 模块生成高频 PWM 信号（替代手动翻转，更稳定）：  
  ```c
  #include "driver/ledc.h"

  #define IR_TX_PIN GPIO_NUM_18
  #define IR_FREQ 10000  // 10kHz 发射频率

  void ir_tx_init() {
    // 配置 LEDC 定时器
    ledc_timer_config_t timer_cfg = {
      .speed_mode = LEDC_LOW_SPEED_MODE,
      .duty_resolution = LEDC_TIMER_8_BIT,
      .timer_num = LEDC_TIMER_0,
      .freq_hz = IR_FREQ,
      .clk_cfg = LEDC_AUTO_CLK
    };
    ledc_timer_config(&timer_cfg);

    // 配置 LEDC 通道（发射引脚输出 PWM）
    ledc_channel_config_t ch_cfg = {
      .gpio_num = IR_TX_PIN,
      .speed_mode = LEDC_LOW_SPEED_MODE,
      .channel = LEDC_CHANNEL_0,
      .timer_sel = LEDC_TIMER_0,
      .duty = 128,  // 50% 占空比（发射持续信号）
      .hpoint = 0
    };
    ledc_channel_config(&ch_cfg);
  }
  ```  

- **接收模块脉冲计数（中断方式）**：  
  编码盘转动时，遮挡/透过红外会导致接收模块电平跳变，通过 GPIO 中断捕获跳变并计数（每跳变一次计一个脉冲）。  
  ```c
  #include "driver/gpio.h"
  #include "esp_log.h"
  #include "freertos/semphr.h"

  #define IR_RX_PIN GPIO_NUM_19
  static const char* TAG = "ENCODER";
  static volatile int pulse_count = 0;  // 脉冲计数（需 volatile 修饰中断变量）
  static SemaphoreHandle_t pulse_sem = NULL;

  // 中断服务函数：检测到电平跳变时计数
  static void IRAM_ATTR ir_rx_isr_handler(void* arg) {
    pulse_count++;
    xSemaphoreGiveFromISR(pulse_sem, NULL);  // 释放信号量通知任务
  }

  void ir_rx_init() {
    pulse_sem = xSemaphoreCreateBinary();  // 创建信号量

    // 配置接收引脚中断（双边沿触发：上升沿+下降沿都计数）
    gpio_config_t rx_config = {
      .pin_bit_mask = (1ULL << IR_RX_PIN),
      .mode = GPIO_MODE_INPUT,
      .pull_up_en = GPIO_PULLUP_ENABLE,
      .pull_down_en = GPIO_PULLDOWN_DISABLE,
      .intr_type = GPIO_INTR_ANYEDGE  // 双边沿触发
    };
    gpio_config(&rx_config);

    // 安装中断服务
    gpio_install_isr_service(0);
    gpio_isr_handler_add(IR_RX_PIN, ir_rx_isr_handler, NULL);
  }

  // 脉冲计数任务：打印当前计数值（供测试）
  void pulse_count_task(void* arg) {
    while (1) {
      if (xSemaphoreTake(pulse_sem, portMAX_DELAY)) {
        ESP_LOGI(TAG, "Pulse count: %d", pulse_count);
      }
    }
  }

  // 在 app_main 中启动
  void app_main() {
    ir_tx_init();    // 初始化发射模块（高频 PWM）
    ir_rx_init();    // 初始化接收模块（中断计数）
    xTaskCreate(pulse_count_task, "pulse_task", 2048, NULL, 5, NULL);
  }
  ```  

- **验证标准**：手动转动车轮，编码盘每转一圈（20 个槽），脉冲计数应增加 20（允许 ±1 误差，因启动/停止位置可能多计一次）。  


##### 步骤 3：距离计算逻辑实现  
**目标**：根据脉冲数和车轮参数，将计数转换为前进距离。  

- **核心公式**：  
  1. 车轮周长 = π × 车轮直径（单位：米，如直径 0.06m，则周长 ≈ 0.1884m）；  
  2. 每脉冲距离 = 车轮周长 / 20（因每圈 20 个脉冲）；  
  3. 总前进距离 = 脉冲数 × 每脉冲距离。  

- **代码实现**：  
  ```c
  class Encoder {
  private:
    float wheel_diameter_;  // 车轮直径（米）
    float pulse_distance_;  // 每脉冲对应的距离（米）
    volatile int pulse_count_;  // 当前脉冲数

  public:
    Encoder(float wheel_diameter) : wheel_diameter_(wheel_diameter) {
      pulse_count_ = 0;
      // 计算每脉冲距离：(π×直径)/20
      pulse_distance_ = (M_PI * wheel_diameter_) / 20.0f;
    }

    // 更新脉冲数（供中断调用）
    void UpdatePulse() {
      pulse_count_++;
    }

    // 获取当前总距离（米）
    float GetDistance() {
      return pulse_count_ * pulse_distance_;
    }

    // 重置计数（用于新的距离测量）
    void Reset() {
      pulse_count_ = 0;
    }
  };

  // 使用示例：假设车轮直径 0.06m
  Encoder encoder(0.06f);
  ```  


##### 步骤 4：与现有电机控制集成  
**目标**：将距离计算逻辑封装到 `main/motor` 中，支持“前进指定距离”的指令。  

- **代码封装（新增 `encoder.h` 和 `encoder.cc` 到 `main/motor`）**：  
  1. 在 `encoder.h` 中定义 `Encoder` 类（包含脉冲计数、距离计算、重置等方法）；  
  2. 在 `encoder.cc` 中实现硬件初始化（红外发射 PWM、接收中断）和计数逻辑；  
  3. 在现有 `MotorControl` 类（`motor_control.cc`）中添加依赖，实现 `MoveDistance(float target_meters)` 方法：  
     ```c
     // 在 MotorControl 中新增方法
     void MotorControl::MoveDistance(float target_meters) {
       encoder_.Reset();  // 重置计数
       Forward(100, 0);  // 启动电机（速度 100，时间 0 表示不自动停止）

       // 循环检测距离是否达标
       while (encoder_.GetDistance() < target_meters) {
         vTaskDelay(pdMS_TO_TICKS(10));  // 10ms 检测一次
       }

       Stop();  // 到达目标距离，停止电机
     }
     ```  

- **MCP 工具注册**：在 `MotorControl::InitializeTools()` 中添加“指定距离前进”的工具，供上层调用：  
  ```c
  mcp_server.AddTool(
      "self.motor.move_distance", "控制电机前进指定距离。distance: 距离(米, 0-5); speed: 速度(0-255)",
      PropertyList({Property("distance", kPropertyTypeFloat, 1.0f, 0, 5),
                    Property("speed", kPropertyTypeInteger, 100, 0, 255)}),
      [this](const PropertyList& properties) -> ReturnValue {
        float distance = properties["distance"].value<float>();
        int speed = properties["speed"].value<int>();
        this->SetSpeed(speed);  // 设置速度
        this->MoveDistance(distance);  // 前进指定距离
        return "已前进 " + std::to_string(distance) + " 米";
      });
  ```  


##### 步骤 5：测试与优化  
- **手动测试**：手动转动车轮，验证脉冲计数与距离计算是否匹配（如转动 1 圈，距离应 ≈ 车轮周长）；  
- **动态测试**：控制小车实际行驶，对比“预设距离”与“实际距离”的误差，调整车轮直径参数（因机械安装可能存在误差）；  
- **抗干扰优化**：若存在误触发，可在中断处理中添加滤波（如连续检测 2 次跳变才计数），或增加硬件滤波电容。  


#### 4. 最终集成路径  
1. 将 `template-app` 中测试通过的红外发射/接收代码，封装为 `Encoder` 类（`main/motor/encoder.h` 和 `encoder.cc`）；  
2. 在现有 `MotorDriver` 或 `MotorControl` 类中添加 `Encoder` 成员变量，关联电机控制逻辑；  
3. 新增“前进指定距离”的接口和 MCP 工具，确保代码符合 Google C++ 风格；  
4. 编译测试，验证功能后提交代码。